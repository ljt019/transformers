# Planning

Pipeline
 - prompt_completion
 - message_completion 

Reasoning
 - No extra methods 

ToggleableReasoning
 - toggle_reasoning

Tool Calling
 - register_tool
 - toggle_tools (toggles wether prompt/message completions use registered tools)

So each model would define which of these things it supports, for example
Qwen3 supports ToggleableReasoning and Tool Calling, so when creating the Qwen3 model file i want to be able to define it has those abilites, and write those methods (for example the logic it takes to specifically toggle it's reasoning)

And then when creating pipeline like we already do with the builder 
```rust 
    let pipeline = TextGenerationPipelineBuilder::new(ModelOptions::Qwen3(Qwen3Size::Size0_6B))
        .temperature(0.7)
        .build()?;
```

we would just make the TextGenerationPipelineBuilder return some generic pipeline that can implement any of those and when you do .build() it builds the appropirate pipeline type based on the model stuff you chose and only exposes methods that model implemments for it.

Is this acheiveable? What's the idiomatic way to go about something like this?